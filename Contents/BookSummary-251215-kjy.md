# 성능을 좌우하는 DB 설계와 쿼리

# 성능에 핵심인 DB

## 풀 스캔(full scan)

테이블의 모든 데이터를 순차적으로 읽는 것

보통 쿼리의 where절에 있는 조건에 대응하는 인덱스가 없을 때 풀 스캔 발생

데이터 개수가 늘어나면 응답 시간 기하급수적으로 증가

→ DB 설계 시 항상 염두에 두어야 함(DB 성능은 서버 성능에 영향을 준다)

# 조회 트래픽을 고려한 인덱스 설계

## 인덱스와 트래픽

DB 테이블 설계 시 조회 기능과 트래픽 규모 고려 필요

데이터양이 적고 동시접속자도 적을 시 굳이 인덱스를 추가할 필요는 없음(풀 스캔 시에도 성능 문제 X)

그러나 데이터 양이 많을 시, 다수의 풀 스캔 시 DB 뻗을 수 있음

- (예) 인기 커뮤니티의 게시글 목록 검색

풀 스캔 발생 않도록 위해서는 조회 패턴을 기준으로 인덱스 설계 필요

## 선택도를 고려한 인덱스 칼럼 선택

인덱스 생성 시 선택도가 높은 컬럼을 골라야 함

선택도: 인덱스에서 특정 칼럼의 고유한 값 비율

- 선택도 ↑ : 해당 칼럼에 고유한 값이 많다
- 선택도가 높을수록 인덱스를 이용한 조회 효율이 높아짐

인덱스로 사용할 칼러을 고를 때 선택도가 항상 높아야 하는 건 아님

## 커버링 인덱스 활용하기

커버링 인덱스: 특정 쿼리를 실행하는 데 필요한 칼럼을 모두 포함하는 인덱스

사용 시 쿼리 실행 효율 높일 수 있음

## 인덱스는 필요한 만큼만 만들기

효과가 적은 인덱스 추가 시 오히려 성능이 나빠질 수 있음 → 인덱스 비용(시간) 추가되기 때문

인덱스가 많아질수록 메모리와 디스크 사용량도 함께 증가

# 몇 가지 조회 성능 개선 방법

## 미리 집계하기

집계 데이터 미리 계산해 별도 칼럼에 저장

## 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용하기

## 조회 범위를 시간 기준으로 제한하기

뉴스 기사 목록 등에 사용하면 좋음

→ 기사 조회 범위를 일자 기준으로 제한

쇼핑 사이트에서 회원의 주문 내역을 조회하는 기능

최신 데이터만 조회하기 (예) 구글의 최근 보안 활동 화면은 최근 28일 데이터만 보여줌

## 전체 개수 세지 않기

데이터가 많아질수록 count 실행 시간도 증가(조건에 해당하는 모든 데이터 탐색 필요)

## 오래된 데이터 삭제 및 분리 보관하기

## DB 장비 확장하기

## 별도 캐시 서버 구성하기

# 추가 주의사항

## 쿼리 타임아웃

응답 지연으로 인한 재시도는 서버 부하를 더욱 가중시킴

→ 이를 막기 위해 쿼리 실행 시간을 제어하기(타임아웃 설정)

## 상태 변경 기능은 복제 DB에서 조회하지 않기

주 DB와 복제 DB는 순간적으로 데이터가 일치하지 않을 수 있음

트랜잭션 이슈

- 주 DB와 복제 DB 간 데이터 복제는 트랜지션 커밋 시점에 이루어짐
- 주 DB의 트랜잭션 범위 내에서 데이터를 변경하고, 복제 DB에서 변경 대상이 될 수 이는 데이터를 조회하면 데이터 불일치로 인해 문제 발생

## 배치 쿼리 실행 시간 증가

배치에서 사용하는 쿼리의 실행 시간을 지속적으로 추적 필요

→ 추적을 통해 문제가 되는 쿼리 발견하여 원인 해결 가능

데이터를 일정한 크기로 나눠 처리하기

커버링 인덱스를 활용하여 처리 속도 ↑, 메모리 ↓

## 타입이 다른 칼럼 조인 주의