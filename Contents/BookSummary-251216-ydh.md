# 데이터베이스 성능 최적화: 풀스캔과 인덱스 설계

## 풀스캔(Full Scan)이란?
- 테이블의 모든 데이터를 순차적으로 읽는 방식
- 데이터가 많고 호출 빈도가 높을 때 풀스캔이 빈번하면 서비스 성능에 심각한 영향

## 인덱스 설계 고려사항
DB 테이블 설계 시 조회/트래픽 규모를 반드시 고려해야 합니다.

- **효과 없는 인덱스 주의**: 조회 속도는 빨라지지만 CUD(Create/Update/Delete) 시 인덱스 관리 비용 추가
- **리소스 증가**: 인덱스 자체도 데이터이므로 메모리/디스크 사용량 증가
- **중복 인덱스 방지**: 같은 컬럼에 인덱스 중복 생성 금지

**예시**: 최대 TPS 10 미만 환경에서 별도 컬럼 인덱스 추가 불필요. 데이터 양 적고 동시 접속자 적어 풀스캔과 성능 차이 없음.

## 전문 검색 인덱스
- 문자열 검색 기능(LIKE 등) → 풀스캔 유발
- **대안**: 별도 검색엔진 또는 DB 전용 기능 사용
  * Oracle Text
  * MySQL FULLTEXT

## 인덱스 유형
### 단일 인덱스
- 단일 컬럼만 대상

### 복합 인덱스
- 여러 컬럼 조합
- **설계 원칙**:
  - 쿼리 실행 빈도/시간 검토
  - **선택도 높은 컬럼 우선** (고유값 비율, Primary Key 등)
  - **예외**: 작업큐처럼 선택도 낮아도 인덱스 유리한 경우 존재

## 커버링 인덱스(Covering Index)
특정 쿼리에 필요한 **모든 컬럼을 인덱스에 포함**하여 테이블 액세스 최소화

## 인덱스 외 성능 개선 방법
- 미리 집계 (비정규화 허용)
- 페이지 기준 → **ID 기준** 목록 조회
- 조회 범위 **시간 제한** (최신 데이터 메모리 캐시 효율↑)
- **전체 COUNT 생략**
- 오래된 데이터 삭제/분리 보관
- DB **수직/수평 확장**
- **캐시 서버** 구성

## 알아두면 좋은 주의사항
- **쿼리 타임아웃** 설정
- 상태 변경 기능은 **복제 DB 조회 금지** (데이터 복제 지연 발생)
- 배치 쿼리 실행시간 길어지면:
  * 커버링 인덱스 고려
  * 데이터 크기 나누어 처리
- **타입 다른 컬럼 조인 주의** (인덱스 활용 불가)
- **DB 트랜잭션 필수** (여러 데이터 수정 시 실수 빈발)
