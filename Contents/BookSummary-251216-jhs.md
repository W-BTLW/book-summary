# 성능을 좌우하는 DB설계와 쿼리

## 풀 스캔(full scan)
- 인덱스가 없을 때 발생하며, 데이터를 순차적으로 조회는 방법
- 데이터 개수가 적을땐 상관없으나 많아지면 어느 순간 응답 시간이 빠르게 증가

## 인덱스 설계
- 트래픽 규모에 따라 인덱스 여부 결정
- 사용량과 데이터량이 많은 경우 조회 패턴을 기준으로 적절한 컬럼에 인덱스 설계
- like 조건은 풀 스캔을 유발함
  - 대안 : Oracle Text나 MySQL FULLTEXT 인덱스 활용
  - ex)
    ```SQL
    # TEXT 인덱스 생성
    CREATE INDEX idx_post_content
    ON post(content)
    INDEXTYPE IS CTXSYS.CONTEXT;

    # 조회
    SELECT *
    FROM post
    WHERE CONTAINS(content, '오라클 인덱스') > 0;
  - 실시간 동기화 안됨, LIKE랑 혼용하다가 성능 저하, 한국어에 최적화X 등 실무활용시 유의포인트 존재
 
## 단일 인덱스와 복합 인덱스
- 데이터가 쌓이는 양과 활용빈도를 고려하여 특정 컬럼을 인덱스에 추가할지 결정

## 커버링 인덱스
- 특정 쿼리를 실행하는 데 필요한 컬럼을 모두 포함하는 인덱스를 말함

## 인덱스도 비용이다
- 인덱스 자체도 데이터며, 관리에 대한 비용이 발생
- 인덱스 추가시 같은 컬럼을 사용하는 인덱스가 중복 추가되지 않는지 확인

## 몇가지 조회 성능 개선 방법
- 집계 값을 저장할 컬럼(ex 조회수)을 특정해 집계시 조회 성능 개선
- pk인 id기준으로 목록 조회 방식 사용하기
- 조회 범위를 시간 기준으로 제한하기
  - 뉴스 기사 목록, 쇼핑 사이트에서 월별 조회 등
- COUNT(*) 자제
  - 해당하는 모든 데이터를 탐색해야함
- 배치 등을 통해 불필요한 데이터 삭제or분리보관하기
- DB장비 확장하기
- 별도 캐시 서버 구성

## 알아두면 좋을 주의사항
- 쿼리 타임아웃
  - 타임아웃을 설정하지 않고 계속해서 새로운 요청이 유입되는 경우 서버 부하 폭증
  - 서비스 특성에 따라 다르게 설정
 
- 상태 변경 기능은 주DB에서 조회하기
  - 주DB-복제DB 구조를 사용할때 동시성 이슈가 있을 수 있음

- 배치 쿼리 실행 시간 증가
  - 데이터가 쌓일수록 배치 쿼리 시간이 어느순간 급증할 수 있음, 지속적 모니터링 필요

- 타입이 다른 컬럼 조인 주의
  - 타입 변환 수행으로 인해 인덱스를 걸어놓더라도 온전히 활용하지 못하게 

- 실패와 트랜잭션 고려하기
  - 데이터수정시 트랜잭션 고려없으면 데이터 일관성에 문제 생김
